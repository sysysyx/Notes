/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DevUtilsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_view = require("@codemirror/view");
var import_view2 = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var obsidian = __toESM(require("obsidian"));

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  obsidianName: "obsidian",
  pluginName: "plugin"
};
var DevUtilsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Obsidian module name").setDesc("Obsidian API is exposed as a global variable with this name.").addText((text) => text.setValue(this.plugin.settings.obsidianName).onChange(async (value) => {
      this.plugin.settings.obsidianName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Plugin variable name").setDesc("The plugin object is available with this name.").addText((text) => text.setValue(this.plugin.settings.pluginName).onChange(async (value) => {
      this.plugin.settings.pluginName = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var import_language = require("@codemirror/language");
var DevUtilsPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.editorExtensions = [];
  }
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new DevUtilsSettingTab(this));
    this.registerEditorExtension(this.editorExtensions);
    this.app.workspace.onLayoutReady(() => this.registerUtilities());
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  registerUtilities() {
    const { app } = this;
    const utils = {
      getMarkdownView() {
        return app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      },
      getFile(name) {
        var _a;
        const activeFile = app.workspace.getActiveFile();
        if (name === void 0)
          return activeFile;
        return app.metadataCache.getFirstLinkpathDest(name, (_a = activeFile == null ? void 0 : activeFile.path) != null ? _a : "");
      },
      getPath() {
        var _a, _b;
        return (_b = (_a = app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : null;
      },
      getEditor() {
        var _a, _b;
        return (_b = (_a = app.workspace.activeEditor) == null ? void 0 : _a.editor) != null ? _b : null;
      },
      getCache(name) {
        const file = utils.getFile(name);
        if (!file)
          return null;
        return app.metadataCache.getFileCache(file);
      },
      getAbsolutePath(name) {
        if (app.vault.adapter instanceof import_obsidian2.FileSystemAdapter) {
          const file = utils.getFile(name);
          if (!file)
            return null;
          return app.vault.adapter.getFullPath(file.path);
        }
        return null;
      },
      getEditorView() {
        var _a, _b;
        return (_b = (_a = utils.getEditor()) == null ? void 0 : _a.cm) != null ? _b : null;
      },
      getEditorState() {
        var _a, _b;
        return (_b = (_a = utils.getEditorView()) == null ? void 0 : _a.state) != null ? _b : null;
      },
      syntaxTree(state) {
        var _a;
        state = (_a = state != null ? state : utils.getEditorState()) != null ? _a : void 0;
        if (!state)
          return null;
        return (0, import_language.syntaxTree)(state);
      },
      printNode(node, state) {
        var _a;
        state = (_a = state != null ? state : utils.getEditorState()) != null ? _a : void 0;
        if (!state)
          return null;
        console.log(`${node.from}-${node.to}: "${state.sliceDoc(node.from, node.to)}" (${node.name})`);
      },
      printNodes(state) {
        const tree = utils.syntaxTree(state);
        if (!tree)
          return null;
        tree.iterate({
          enter(node) {
            utils.printNode(node, state);
          }
        });
      }
    };
    for (const [name, fn] of Object.entries(utils)) {
      this._registerToWindow(name, fn);
    }
    this._registerToWindow(this.settings.obsidianName, obsidian);
    this._registerToWindow(this.settings.pluginName, this);
  }
  _registerToWindow(name, obj) {
    (window[name] = obj) && this.register(() => delete window[name]);
  }
  addUpdateListener(callback) {
    this.registerEditorExtension(import_view2.EditorView.updateListener.of(callback));
  }
  clearUpdateListeners() {
    this.editorExtensions.length = 0;
    this.app.workspace.updateOptions();
  }
  setUpdateListener(callback) {
    this.clearUpdateListeners();
    this.addUpdateListener(callback);
  }
};
