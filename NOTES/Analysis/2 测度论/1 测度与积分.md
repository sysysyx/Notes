# 预备工具: 集类和单调类定理

假定我们有一空间 $\Omega$, 其部分子集构成的集合称为其上的一个集类, 对于一个集类 $\{A_i:i\in I\}$, 可以定义其中元素的交与并
$$\begin{align}
\bigcup_{i\in I}A_i&:=\{w:\forall i,w\in A_i\}\\
\bigcap_{i\in I}A_i&:=\{w:\exists i,w\in A_i\}
\end{align}$$
注意这并不对指标集的基数和运算作任何要求, 并且天生具有交换性.

同时对于可列多个集合 $A_n\ (n\in \mathbb N^*)$ 我还可以定义其极限
$$\begin{align}
\limsup_{n\to\infty} A_n&:=\bigcap_{k=1}^\infty\bigcup_{n=k}^\infty A_n=\{w:\forall N>0,\exists n>N,w\in A_n\}\\
\liminf_{n\to\infty} A_n&:=\bigcup_{k=1}^\infty\bigcap_{n=k}^\infty A_n=\{w:\exists N>0,\forall n>N,w\in A_n\}
\end{align}$$
并且若上极限和下极限相等, 将其定义为 $\lim_{n\to\infty}A_n$

我们希望在集类中作交并补取极限等运算, 定义一些描述语言, 对集类 $\mathcal C$:
- 称 $\mathcal C_{\cap f}$, $\mathcal C_{\cup f}$, $\mathcal C_{\Sigma f}$, $\mathcal C_\sigma$, $\mathcal C_{\delta}$ 分别表示 $\mathcal C$ 的有限交, 有限并, 有限不交并, 可列交, 可列并组成的集类. 例如
$$\mathcal C_{\cap f}:=\left\{\bigcap_{i=1}^nA_i:n\in\mathbb N,A_i\in\mathcal C\right\}$$
- 称 $\mathcal C$ 为 **$\pi$ 类**, 若 $\mathcal C$ 对有限交封闭
- 称 $\mathcal C$ 为**半环**, 若 $\emptyset\in\mathcal C$, 且
$$A,B\in\mathcal C\Longrightarrow A\cap B\in\mathcal C,\ A\setminus B\in\mathcal C_{\Sigma f}$$
- 称 $\mathcal C$ 为**半代数**, 如果它是半环且 $\Omega\in\mathcal C$
- 称 $\mathcal C$ 为**代数** (或**域**), 如果它对有限交及取余集运算封闭, 且 $\Omega,\emptyset\in\mathcal C$
(可见它比半代数更高的要求是 $A\setminus B\in\mathcal C$ 而不是 $\mathcal C_{\Sigma f}$, 并且容易推出其中允许有限的交并差)
- 称 $\mathcal C$ 为 **$\sigma$-代数**, 如果它对可列交及取余集运算封闭且 $\Omega,\emptyset\in\mathcal C$
(相比代数, $\sigma$-代数内允许可列的交并补)
- 称 $\mathcal C$ 为**单调类**, 若它对单调序列的极限封闭
- 称 $\mathcal C$ 为 **$\lambda$ 类**, 若它满足
	- $\Omega\in\mathcal C$;
	- $A,B\in\mathcal C, B\subset A\Rightarrow A\setminus B\in \mathcal C$
	- $\mathcal C\ni A_n\uparrow A\Rightarrow A\in\mathcal C$
- 特别地, 我们约定 $m(\mathcal C)$, $\lambda(\mathcal C)$, $\sigma(\mathcal C)$ 为含 $\mathcal C$ 的最小单调类, $\lambda$ 类和 $\sigma$-代数.

```tikz
\usepackage{tikz-cd}
\begin{document}
% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBoAGAXVJADcBDAGwFcYkQAdDnGADx2DYAtlgC0AJyxgA5gF8Qs0uky58hFOQrU6TVuy5osXHv2AACAMaN6cOPMXLseAkQBMWmgxZtEnbnwFhMSZpGAAjcXp7JRAMJzUiAGYPHW99f1MQ8Mjox1UXFAAWUmJtLz1fLmxpIXpjAOBRLIiohRi4-PVkd1cy3R8-EwEhAggcAiwLS2tbXNiVZy7k3s9+9OshMKg6jIFRCyZZhW0YKFCEFFAAM3EIISQyEHGkcgcQG7uXmmfEVzeP+6-b4QJCJf63QHJJ4gxCFcGfRAAVmBSAAbPDAaiUbDZJRZEA
\begin{tikzcd}
\pi\mbox{ class} \arrow[r] & \mbox{simi-ring} \arrow[r] & \mbox{simi-algebra} \arrow[r]    & \mbox{algebra} \arrow[rd]       &                       \\
                           &                            &                                  &                                 & \sigma\mbox{-algebra} \\
                           &                            & \mbox{monotonic class} \arrow[r] & \lambda\mbox{-calss} \arrow[ru] &                      
\end{tikzcd}

\end{document}
```

总之我们的最终目标是搓一个 $\sigma$-代数出来, 其重要工具是单调类定理, 粗略地说

> [!lem]
> $$代数 + 单调类 = \sigma\text{-代数}\qquad \pi\ 类+\lambda\ 类=\sigma\text{代数}$$

^7c38e5

`BEGINPROOF`
$$A=\bigcup_{n=1}^\infty A_n=\underbrace{\lim_{N\to\infty}}_{单调类}\ \underbrace{{\bigcup_{n=1}^N A_n}}_{代数}=\Omega\setminus \left(\lim_{N\to\infty}\bigcap_{n=1}^N A_n^c \right)$$
`ENDPROOF`

> [!thm] 单调类定理
> 若 $\mathcal C$ 为一代数, 则 $m(\mathcal C)=\sigma(\mathcal C)$
> 若 $\mathcal C$ 为一 $\pi$ 类, 则 $\lambda(\mathcal C)=\sigma(\mathcal C)$

**思路:** 

由 [[#^7c38e5]], 只需证 $m(\mathcal C)$ 为一代数, 第一个尝试是直接写出
$$m(\mathcal C)\xlongequal{\text{claim 1}}\underbrace{\{A:\exists \mathcal A(n)\in \mathbb N^\mathcal C,\lim_{n\to\infty}\mathcal A(n)=A\}}_{\mathcal G}\xlongequal{\text{claim 2}}\sigma(\mathcal C)$$
$\mathcal G$ 显然是个代数, 也就是说 Claim 2 是显然的;
对于 Claim 1, $\mathcal C\subset m(\mathcal C)\Rightarrow\mathcal G\subset m(\mathcal C)$, 由 $m(\mathcal C)$ 为最小的单调类, 只需证 $\mathcal{G}$ 为一单调类即可, 对 $\mathcal C\ni A_n\uparrow A$, 由定义取 $\mathcal C\ni A_n^{(i)}\uparrow A_n$, 往证 $\bigcup_{i\leq n}A_i^{(n)}\uparrow A$:
$$\lim_{n\to\infty}\bigcup_{i\leq n}A_i^{(n)}=\bigcup_n\bigcup_{i\leq n} A_i^{(n)}=\bigcup_{n,i}A_n^{(i)}=\bigcup_n\bigcup_i A_n^{(i)}=A$$
这其中并集的任意换序发挥了重大作用.

但是对于 (2), 我们并没有具体的表述可以使用, 此时可以关注单调类定义中的 "最小", 也就是说我们可以对其加上任意的限制, 只要得到的子集仍是单调类, 那么这个子集就必然是其本身, 看起来就像凭空造出来 (或者验证了) 某些性质一样, 用这个方法可以直接验证 $m(\mathcal C)$ 为代数, $\lambda(\mathcal C)$ 为 $\pi$ 类

`BEGINPROOF`
(1) 令 
$$\mathcal G_1:=\{A:A\in m(\mathcal C),A^c\in m(\mathcal C),\forall_{B\in\mathcal C}, A\cap B\in m(\mathcal C)\}$$
则 $\mathcal C\in\mathcal G_1$, 且 $\mathcal G_1$ 为一单调类, 从而 $\mathcal G_1=m(\mathcal C)$, 再令
$$\mathcal G_2:=\{A:A\in m(\mathcal C), \forall_{B\in m(\mathcal C)},A\cap B\in m(\mathcal C)\}$$
由上述对 $\mathcal G_1$, 的讨论, $\mathcal C\in\mathcal G_2$, 而 $\mathcal G_2$ 为一单调类, 从而 $\mathcal G_2=m(\mathcal C)$, 则
$$A\in m(\mathcal C)\Rightarrow A^c\in m(\mathcal C),\quad A,B\in\mathcal C\Rightarrow A\cap B\in\mathcal C$$
即 $m(\mathcal C)$ 为一代数, 由 [[#^7c38e5]] 证毕

(2) 类似地, 令
$$\mathcal G_1:=\{A:A\in\lambda(\mathcal C),\forall_{B\in C},A\cap B\in\lambda(\mathcal C)\}$$
则 $\mathcal C\subset \mathcal G_1$, 且 $\mathcal G_1$ 为一 $\lambda$ 类, 从而 $\mathcal G_1=\lambda(\mathcal C)$, 再令
$$\mathcal G_2:=\{A:A\in\lambda(\mathcal C), \forall_{B\in\lambda(\mathcal C)},A\cap B\in\lambda(\mathcal C)\}$$
由上述对 $\mathcal G_1$ 的讨论, $\mathcal C\subset \mathcal G_2$, 而 $\mathcal G_2$ 为一 $\lambda$ 类, 这说明 $\lambda(\mathcal C)=\mathcal G_2$, 即 $m(\mathcal C)$ 为一 $pi$ 类, 由 [[#^7c38e5]] 证毕
`ENDPROOF`
#递降/最小性

- 这里的 $\mathcal G_1$, $\mathcal G_2$ 并不完全是递进关系, 而是先想到 $\mathcal G_2$, 再给出 $\mathcal G_1$ 作为补充
- 类似的命题 $\mathcal C$ 为一单调类不能推出 $\sigma(\mathcal C)=\operatorname{alg}(\mathcal C)$, 这体现出简单的交并补运算在可列极限上的继承性比极限在交并补上的更好
- 单调类定义保证我们在证明 $\sigma$-代数的某些性质的时候可以取出一组类似基的生成代数 ($\pi$ 类) 中的元素具有该性质, 再说明具有该性质的元素全体构成一单调类 ($\lambda$ 类), 后二者往往容易验证


